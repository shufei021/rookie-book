### JavaScript 高级部分

##### 1.什么是原型？

> 每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性

> 当每一个函数创建时,都会给函数设置一个prototype(原型)属性,这个属性是一个指针,指向一个对象,这个对象包含所有实例共享的属性和方法,在默认情况下,都会为prototype对象添加一个constructor属性,指向该函数。

##### 2.什么是原型链？

> ECMA中继承的主要方法就是通过原型链,主要是一个原型对象等于另一个类型的实例,由于实例内部含有一个指向构造函数的指针,这时候相当于重写了该原型对象,此时该原型对象就包含了一个指向另一个原型的指针,假如另一个原型又是另一个类型的实例,这样就形成了原型链的概念,原型链最底层为Object.prototype.__proto__,为null。

> **每个对象（除null外）创建的时候，都会为其设置一个原型 `__proto__`,这个原型还可以有它自己的原型，以此类推，形成一个原型链**

> 查找特定属性的时候，会先去这个对象里去查找，找不到会再去它的原型对象里面去找，以此类推，原型链最底层是`Object.prototype.__proto`__ 为null

##### 3.继承？

> 子类继承父类的属性和方法，同时也可以增加子类自己的属性和方法，也可以改写或覆盖继承到的属性和方法，继承的优势：代码的抽象和代码的复用

##### 4.什么是面向对象编程（OOP）？

> 简单来说，面向对象编程就是将你的业务需求抽象成一个对象，然后对这个对象进行分析，为其添加对应的特征（属性）与行为（方法），我们将这个对象称之为 类。

##### 5.闭包？

+ 概念：

  > 闭包就是能够读取其他函数内部变量的函数

+ 用途：

  - 可以读取函数内部的变量
  - 让这些变量的值始终保持在内存中
  - 防止变量被污染

+ 缺点：

  + 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
  + 闭包会在父函数外部，改变父函数内部变量的值。

##### 6.同源策略？



> **同源策略**限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。(来源：MDN web docs)

> 同源策略 是由NetScape提出的一个著名的安全策略。所谓的同源，指的是**协议**，**域名**，**端口**相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。

##### 7.Cookie、localStorge、sessionStorage的区别？

+ 数据的生命周期：
  - Cookie一般有服务器生成，可设置失效时间，如果在浏览器端生成，默认是关闭浏览器失效；
  - localStorge除非被清除，否则永久保存；
  - sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除；
+ 存放数据大小：
  - Cookie是4k左右
  - localStorge和sessionStorage一般在5MB左右；
+ 与服务器通信：
  - Cookie每次都会携带在HTTP头中，不宜使用Cookie保存过多数据；
  - localStorge和sessionStorage仅在客户端（即浏览器）中保存，不参与和服务器的通信；
+ 易用性：
  - Cookie源生API不够友好，需要程序员组件封装；
  - localStorge和sessionStorage源生接口可以接受，但也可再次封装，以对object和array有更好的支持；

##### 8.用户输入url到按下enter返回页面，中间发生了什么？

+ 解析DNS，发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；
+ 与web服务器建立TCP连接；
+ 浏览器想web服务器发送http请求；
+ web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；
+ 浏览器下载web服务器返回的数据及解析html源文件；
+ 生成DOM树和CSSOM，解析js，生成render数，layout（布局），GPU painting（像素绘制页面）；

##### 9.vue生命周期？

+ 实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作
+ 挂载数据，绑定事件等等，然后执行created函数，**这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数**，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做**初始数据的获取**
+ 接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取
+ 接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情...
+ 当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿
+ 当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom
+ 当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等
+ 组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以

#### 作用域？作用域链？

