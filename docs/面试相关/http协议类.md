## HTTP 协议

#### http协议简介

> HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。
>
> HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。
>
> HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。
>
> HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。

> **简记：**
>
> HTTP协议是 **超文本传输协议** 的缩写
>
> 一般通过TCP/IP通信协议来传递数据
>
> 用于从**万维网服务器** 传输 **超文本** 到 **本地浏览器** 的 **传送协议**

#### http协议的主要特点

+ **简单快速**

  > **客户向服务器请求服务时，只需传送请求方法和路径**。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

+ **灵活**

  > HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记

+ **无连接**

  > 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

+ **无状态**

  > HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

#### http报文的组成部分

+ 请求报文

  - 请求行

    > 请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.

  - 请求头

    > 请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息

  - 空行

    > 空行，请求头部后面的空行是必须的

  - 请求体

    > 请求数据也叫主体，可以添加任意的其他数据。

+ 响应报文

  - 状态行
  - 响应头
  - 空行
  - 响应体

#### http方法

+ GET

  > 获取资源

+ POST

  > 传输资源

+ PUT

  > 更新资源

+ DELETE

  > 删除资源

+ HEAD

  > 获取报文首部

#### POST 和 GET 的区别

+ **GET 在浏览器回退时是无害的，而POST 会再次提交请求**
+ **GET产生的URL地址可以被收藏，而POST不可以**
+ GET请求会被浏览器主动缓存，而POST不会，除非手动设置
+ GET请求只能进行url编码，而PSOT支持多种编码方式
+ **GET请求参数会被完整的保留在浏览器的历史记录中，而POST的参数不会被保留**
+ **GET请求在URL中传输的参数是有长度限制的，而POST没有限制**
+ 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
+ GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传输敏感信息
+ **GET参数通过URL传递，POST参数是放在Request body中**

#### HTTP状态码

+ 1xx：指示信息 - 表示请求已接收，继续处理
+ 2XX：成功 - 表示请求已成功被接收
+ 3XX：重定向 - 要完成请求 必须要进行更进一步的操作
+ 4XX：客户端错误 - 请求有语法错误或请求无法实现
+ 5XX：服务器错误 - 服务器未能实现合法的请求

> 200 OK：客户端请求成功
>
> 206 Partial Content：客户端发送了一个带有Range头的GET请求，服务器完成了它，场景：返回音频地址
>
> 301 Moved Permanently：所请求的页面已经转移至新的url
>
> 302 Found：所请求的页面已经**临时**转移至新的url
>
> 304 Not Modified：客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用
>
> 400 Bad Request：客户端请求有语法错误，不能被服务器所理解
>
> 401 Unanthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用
>
> 403 Forbidden：对被请求页面的访问被禁止
>
> 404 Not Found：请求资源不存在
>
> 500 Internal Server Error：服务器发生不可预期的错误 原来缓冲的文档还可以继续使用
>
> 503 Server Unavailable：请求未完成，服务器临时过载 或 当机，一段时间后可能恢复正常

#### 什么是持久链接

**是使用同一个 TCP 连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。**



> http是支持持久连接的，http1.1开始支持，http1.0是不支持的

> http协议采用 **“请求 - 应答”** 模式，当使用普通模式，即 **非 Keep-Alive 模式**时，每个请求/应答，客户和服务器都要新建一个连接，完成之后立即断开连接（**http协议为无连接的协议**）

> 当使用**Keep-Alive**模式 （又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive 功能避免了建立 或者 重新建立连接

#### 什么是管线化

**是将多个**HTTP**请求（request）整批提交的技术，而在发送过程中不需先等待伺服端的回应。**



> 在使用持久连接的情况下，某个连接上的消息传递类似于：
>
> 请求1 - > 响应1 ->请求2 - > 响应2 -> 请求3 - > 响应3



> 某个连接上的消息变成了类似这样：
>
> **请求1 - > 请求2 -> 请求3 - > 响应1 ->  响应2 - > 响应3**



**管线化的特点**

+ 管线化机制通过持久连接完成，仅HTTP1.1支持此技术
+ 只有GET和HEAD 请求可以进行管线化，而POST则有所限制
+ 初次创建时，不应该启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议
+ 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变
+ HTTP/1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可
+ 由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不友好，因此现代浏览器如Chrome 和 Firefox 默认并未开启管线化支持